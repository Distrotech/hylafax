#!/bin/sh
#    $Id$

#
# This holds various functions that are common to the
# various bin scripts.
#

#
# For getting all of the "faxinfo" items to line up.
#
setInfoSize()
{
    INFOSIZE=0
    for ITEM in DICTSENDER DICTPAGES DICTQUALITY DICTSIZE DICTRECEIVED \
		DICTTIMETORECV DICTSIGNALRATE DICTDATAFORMAT DICTERRCORRECT \
		DICTCALLID1 DICTCALLID2 DICTCALLID3 DICTCALLID4 DICTCALLID \
		DICTCALLID6 DICTCALLID7 DICTRECEIVEDON DICTCOMMID; do
	THISLEN="`eval echo "$"$ITEM | wc -m | $SED 's/ //g'`"
	if [ $THISLEN -gt $INFOSIZE ]; then INFOSIZE=$THISLEN; fi
    done
}

#
# For getting all of the notify job items to line up.
#
setItemSize()
{
    ITEMSIZE=0
    for ITEM in DICTDESTINATION DICTJOBID DICTGROUPID DICTSENDER DICTMAILADDR \
		DICTCOMMID DICTMODEM DICTSUBMITTEDFROM DICTPAGEWIDTH \
		DICTPAGELENGTH DICTRES DICTSTATUS DICTDIALOGS DICTDIALS \
		DICTCALLS DICTPAGES DICTATTEMPTS DICTDIRNUM DICTRECEIVER DICTQUALITY \
		DICTPAGEWIDTH DICTPAGELENGTH DICTDATAFORMAT DICTREMOTEEQUIPMENT \
		DICTREMOTESTATION DICTSIGNALRATE; do
	THISLEN="`eval echo "$"$ITEM | wc -m | $SED 's/ //g'`"
	if [ $THISLEN -gt $ITEMSIZE ]; then ITEMSIZE=$THISLEN; fi
    done
}

faxInfo()
{
    $INFO -n $1 | $SED -e "s/^ *Sender:/`printf %$INFOSIZE\s "$DICTSENDER"`:/g" \
		-e "s/^ *Pages:/`printf %$INFOSIZE\s "$DICTPAGES"`:/g" \
		-e "s/^ *Quality:/`printf %$INFOSIZE\s "$DICTQUALITY"`:/g" \
		-e "s/^ *Page:/`printf %$INFOSIZE\s "$DICTSIZE"`:/g" \
		-e "s/^ *Received:/`printf %$INFOSIZE\s "$DICTRECEIVED"`:/g" \
		-e "s/^ *TimeToRecv:/`printf %$INFOSIZE\s "$DICTTIMETORECV"`:/g" \
		-e "s/^ *SignalRate:/`printf %$INFOSIZE\s "$DICTSIGNALRATE"`:/g" \
		-e "s/^ *DataFormat:/`printf %$INFOSIZE\s "$DICTDATAFORMAT"`:/g" \
		-e "s/^ *ErrCorrect:/`printf %$INFOSIZE\s "$DICTERRCORRECT"`:/g" \
		-e "s/^ *CallID1:/`printf %$INFOSIZE\s "$DICTCALLID1"`:/g" \
		-e "s/^ *CallID2:/`printf %$INFOSIZE\s "$DICTCALLID2"`:/g" \
		-e "s/^ *CallID3:/`printf %$INFOSIZE\s "$DICTCALLID3"`:/g" \
		-e "s/^ *CallID4:/`printf %$INFOSIZE\s "$DICTCALLID4"`:/g" \
		-e "s/^ *CallID5:/`printf %$INFOSIZE\s "$DICTCALLID5"`:/g" \
		-e "s/^ *CallID6:/`printf %$INFOSIZE\s "$DICTCALLID6"`:/g" \
		-e "s/^ *CallID7:/`printf %$INFOSIZE\s "$DICTCALLID7"`:/g" \
		-e "s/ Yes$/ $DICTYES/g" \
		-e "s/ No$/ $DICTNO/g" \
		-e "s/ Normal$/ $DICTNORMAL/g" \
		-e "s/ Fine$/ $DICTFINE/g"
}

parseQfile()
{
    # In shell scripts, there are no special characters in hard-quoted
    # strings (quoted with (')). Single-quotes can't even be escaped
    # inside such strings and must be put outside of them. We thus replace
    # (') with ('\'') which terminates the current string, adds a single
    # quote and starts a new string.
    #
    # New lines in eval could cause problems so we escape them. As with
    # single quotes above, we must first close the current string, add
    # the escaped new line (double quoted) and start a new string.
    #
    # print out variable name and value so we can eval it in the shell
    eval `($AWK -F: ' 
    function p(varname,val)
    {
        gsub(/\\047/, "\047\\\\\047\047", val);
        gsub(/\n/, "\047\042\\\\n\042\047", val);
        printf "%s=\\047%s\\047\n",varname,val
    }
    BEGIN {
        nfiles = 0;
        npins = 0;
        pagewidth = 0;
        pagelength = 0;
        resolution = 0;
        jobtype = "facsimile";
        signalrate = "unknown";
        dataformat = "unknown";
        doneop = "default";
        pagernum = "unknown";
        commid = "";
	csi = "";
	equipment = "";
	station = "";
    }
    /^csi/	{ p("csi",$2); }
    /^nsf/	{ p("equipment",$3); }
    /^nsf/	{ p("station",$5); }
    /^jobid/    { p("jobid",$2); }
    /^groupid/    { p("groupid", $2); }
    /^state/    { p("state", $2+0); }  
    /^doneop/    { p("doneop", $2); }
    /^number/    { p("number", $2); }
    /^external/    { p("number", $2); }        # override unprocessed number
    /^receiver/    { p("receiver", $2); }
    /^company/    { p("company", $2); }
    /^sender/    { p("sender", $2); }
    /^mailaddr/    { p("mailaddr", $2); }
    /^owner/    { p("owner", $2); }
    /^jobtag/    { jobtag = $0; sub("jobtag:", "", jobtag); p("jobtag", jobtag)}
    /^jobtype/    { p("jobtype", $2); }
    # status needs to be used in the shell as faxstatus since status is reserved word
    /^status/    { status = $0; sub("status:", "", status);
              while ($0 ~ /\\\\$/ && getline > 0) {
                  sub(/\\\\$/, "\\n", status);
                  status = status $0;
              } p("faxstatus", status);
            }
    /^resolution/    { p("resolution", $2); }
    /^npages/    { p("npages", $2); }
    /^totpages/    { p("totpages", $2); }
    /^dirnum/    { p("dirnum", $2); }
    /^commid/    { p("commid", $2); }
    /^ntries/    { p("ntries", $2); }
    /^ndials/    { p("ndials", $2); }
    /^pagewidth/    { p("pagewidth", $2); }
    /^pagelength/    { p("pagelength", $2); }
    /^signalrate/    { p("signalrate", $2); }
    /^dataformat/    { p("dataformat", $2); }
    /^modem/    { p("modem", $2); }
    /^totdials/    { p("totdials", $2); }
    /^tottries/    { p("tottries", $2); }
    /^client/    { p("client", $2); }
    /^[!]*post/    { p("files_"++nfiles, $4); p("filetype_"nfiles, "PostScript"); }
    /^[!]*tiff/    { p("files_"++nfiles, $4); p("filetype_"nfiles, "TIFF"); }
    /^[!]*pdf/    { p("files_"++nfiles, $4); p("filetype_"nfiles, "PDF"); }
    /^[!]*pcl/    { p("files_"++nfiles, $4); p("filetype_"nfiles, "PCL"); }
    /^page:/    { p("pins_"++npins, $4); }
    /^data:/    { p("files_"++nfiles, $4); }
    /^poll/        { p("poll", " -p"); }
    END { p("nfiles", nfiles); p("npins", npins) } ' $QFILE )`

}

parseFaxInfo()
{
    # We use the same basic stuff as parseQfile(), but just to straight assignment
    eval `$INFO -S '' -s '%s=!=!=!=!=!=!=!=!=' $1 | $AWK -F'=!=!=!=!=!=!=!=!=' '
    function p(varname,val)
    {
        gsub(/\\047/, "\047\\\\\047\047", val);
        gsub(/\n/, "\047\042\\\\n\042\047", val);
        printf "%s=\\047%s\\047\n",varname,val
        printf "export %s\n",varname
    }
    { p(toupper($1),$2); }
    '`
}

